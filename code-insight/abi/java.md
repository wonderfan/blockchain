# ABI in Java Contract

## Compiler

The compiler class is provoded to compile the class. The input parameter for the main method is jar file. There are two arguments for the main method. One is the jar file path, the other is version. The version is refered to abi version number. After the jar file is compiled, the output is written into new file. The class reader and writer from asm package are used to read the byte code form. The callable and initializable methods are annotated and gathered from the class. The method name and its parameter type can be collected for ABI information. The method visitor is used to process the method. With the assistance of method visitor, the method can be validated and method data can be extracted from the method signature.

The visitor can be applied into Java class. The visitor can be class level, field level or method level. The jvm can be modified and changed. New elements can be added into the source code. Rigster, stack and thread stuff are all aspects of architecture consideration. The assembler is created to handle the assemble code stuff. The compiler is constructed to process the constant, variables and operation codes. 

The runtime is the instructions for different type operations. The code generation is the final step of compilation procedure. It includes compile, assemble, link, runtime and intermediate representation. The heap is memory area and memory allocation. The system is referred to operation system and system call. It has the content of memory management, signal handling and process management. Some cpp files and codes are added to extend previous system. The conditional directive can be used in the source code for conditional compilation. The dependent files are included and necessary macro variables are defined. A full set of interfaces are related to socket. The additional classes are injected into the sdk layers and compiled together. The header files are added to offer new offerings. The software will run in the different target computer architecture. The high-level language and low-level language are utilized to fulfill the functionalities. Most of low-level language is assembly language. The macro constant can make the code more semantic. 

The target file is found by the file name. The content and its lines are iterated and obtain the expected content and main class. The main flow is find the main class from the jar file, start the jvm and execute the main class method. 

## OpenJDK

The main method passes the process right to the launch method. In the launch method, the execution environment is created and the jvm is initialized. The new thread is created to launch java virtual machine. The main method is called by the main thread.The java native call can be executed in the current thread or new thread by operating system thread. The system call is performed in the low level programming language. 

The launcher is helper class and written in java language. It is enumeration type. Lots of static fields are defined in the class body. The system class loader is used in the launcher helper class. The switch case statement is used to show different kinds of settings like virtual machine, properties and locale. The virtual machine contains stack, heap, machine class properties. The properties is get from system class and print them out. The message is parsed and printed according to their pattern. The main class can be acquired from jar file. The class is able to be loaded by system class loader. The method can be acquired by infection approach. 