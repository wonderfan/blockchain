# ABI in Java Contract

## Compiler

The compiler class is provoded to compile the class. The input parameter for the main method is jar file. There are two arguments for the main method. One is the jar file path, the other is version. The version is refered to abi version number. After the jar file is compiled, the output is written into new file. The class reader and writer from asm package are used to read the byte code form. The callable and initializable methods are annotated and gathered from the class. The method name and its parameter type can be collected for ABI information. The method visitor is used to process the method. With the assistance of method visitor, the method can be validated and method data can be extracted from the method signature.

The visitor can be applied into Java class. The visitor can be class level, field level or method level. The jvm can be modified and changed. New elements can be added into the source code. Rigster, stack and thread stuff are all aspects of architecture consideration. The assembler is created to handle the assemble code stuff. The compiler is constructed to process the constant, variables and operation codes. 

The runtime is the instructions for different type operations. The code generation is the final step of compilation procedure. It includes compile, assemble, link, runtime and intermediate representation. The heap is memory area and memory allocation. The system is referred to operation system and system call. It has the content of memory management, signal handling and process management. Some cpp files and codes are added to extend previous system. The conditional directive can be used in the source code for conditional compilation. The dependent files are included and necessary macro variables are defined. A full set of interfaces are related to socket. The additional classes are injected into the sdk layers and compiled together. The header files are added to offer new offerings. The software will run in the different target computer architecture. The high-level language and low-level language are utilized to fulfill the functionalities. Most of low-level language is assembly language. The macro constant can make the code more semantic. 

The target file is found by the file name. The content and its lines are iterated and obtain the expected content and main class. The main flow is find the main class from the jar file, start the jvm and execute the main class method. 